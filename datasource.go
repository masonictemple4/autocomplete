package autocomplete

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	"cloud.google.com/go/storage"
	"github.com/google/go-github/v53/github"
	"golang.org/x/oauth2/google"
)

// Here you will find the public DataProvider interface, and the DataSource definitions.
// We have also included a few out of the box providers for your convenience.
//
// Included Providers:
// - LocalFileProvider - Allows you to read and write data from a local file.
// - GoogleStorageBucketProvider - Allows you to read and write data from a Google Cloud Storage bucket.
// - GithubProvider - Allows you to read and write data from a Github repository.

// DataProvider is an interface that allows a DataSource of some kind, to be used
// to update the data inside of our AutoCompleterService store or export the data from the
// store to the DataSource.
type DataProvider interface {
	ReadData(fileName string, store PublicProviderStore, fmtr Formatter) error
	DumpData(fileName string, store PublicProviderStore, fmtr Formatter) error
	Close() error
}

// By implementing this interface the user can mock their store when testing their custom
// providers. This allows us to keep the autocomplete interface private. While at the time
// this also satisfies the interface of our AutoCompleterService store which is what will
// be passed into these formatting methods when executed by the service.
type PublicProviderStore interface {
	Insert(word string)
	ListContents() []string
}

// DataSource Either a source or destination for reads and exports.
// Use this when you have a resource that you would like to use to
// populate keywords into the AutoCompleter store. You will also
// use this when exporting the data and snapshots from the Autocompleter.
//
// NOTICE: We have placed the formatter on the DataSoruce and not the Provider.
// This is because we wanted to allow for flexible data formatting based on the source.
// You may have one file that is in a JSON format or another that is in a CSV format
// if both files were coming from the same provider one of them would fail.
//
// We did not think it was necessary to add user cli input to this process. Those
// can be handled when generating the Auto completer service..
type DataSource struct {
	Provider  DataProvider
	Formatter Formatter
	Filepath  string
	Url       string
}

// Will add a default formatter if nil is provided for fmtr. The please see formatter/formatter.go DefaultFormatter
// for more information.
func NewDataSource(provider DataProvider, fmtr Formatter, filepath string, url string) *DataSource {
	if fmtr == nil {
		fmtr = DefaultFormat{}
	}
	return &DataSource{
		Provider:  provider,
		Formatter: fmtr,
		Filepath:  filepath,
		Url:       url,
	}
}

// The Github provider allows a user to read and write data directly from a Github repository.
// Because we are using the Github client for golang this requires that you have a valid access
// token for the repositories that you're using as providers. UNLESS you are using the SourceOnly
//
// In the event that you wish to add a data source that is a public third party repository and you
// do not wish to clone it to access it using your authorized client. You can set SourceOnly to true.
// This will prevent writes from happening with this provider, but will allow Reads.
//
// NOTE: To use a SourceOnly provider make to pass an empty string to NewGithubProvider for the authToken.
//
// When set up as your own authroized client, Dumping the data will check for an existing branch that,
// matches the autogenerated name in the Dump method. If it doesn't exist already, we create it. Then
// we create a new file in that branch with the contents of the data and commit it with the msg provided.
//
// Example client:
//
//	 src := GithubProvider{
//		 Config: GithubOpts{
//			 AuthorName:  "<username>",
//			 AuthorEmail: "<email>",
//			 Repository:  "<repo>",
//			 BaseBranch:  "<branch>",
//		 },
// 	   client: github.NewClient(token),
//	 }

type GithubProvider struct {
	Config     GithubOpts
	SourceOnly bool

	client *github.Client

	clientClosed bool

	mu sync.Mutex
}

type GithubOpts struct {
	AuthorName  string
	AuthorEmail string
	Repository  string
	BaseBranch  string
}

// NewGithubProvider is a factory method for creating a new GithubProvider.
// NOTE: If you wish to use the SourceOnly feature of the GithubProvider, you must
// pass an empty string for the authToken.
func NewGithubProvider(authToken string, opts GithubOpts) *GithubProvider {
	// https://godoc.org/github.com/google/go-github/github#example-RepositoriesService-CreateFile
	ctx := context.Background()
	provider := &GithubProvider{Config: opts}

	if authToken != "" {
		provider.client = github.NewTokenClient(ctx, authToken)
	} else {
		provider.client = github.NewClient(nil)
	}

	return provider
}

// Really doesn't do much other than set the closed flag to true.
// And remove any references to the client.
// If the github.Client, implements a Transport with CloseIdleConnections() method
// then any idle connections will be closed, otherwise this method is a no-op.
func (g *GithubProvider) Close() error {
	g.mu.Lock()
	defer g.mu.Unlock()

	if g.clientClosed || g.client == nil {
		return nil
	}

	// There really isn't a cleanup/close method on the github.Client(), however
	// i did find that they're using a http.Client() under the hood. So we can
	// close the idle connections on that client because they're using a &http.Transport object.
	// which implements the CloseIdleConnections() method.
	g.client.Client().CloseIdleConnections()
	g.client = nil

	g.clientClosed = true

	return nil
}

func (g *GithubProvider) ReadData(fileName string, store PublicProviderStore, fmtr Formatter) error {
	g.mu.Lock()
	defer g.mu.Unlock()

	if g.client == nil {
		return errors.New("datasource githubprovider: cannot read from github without a valid access token or client.")
	}

	file, _, resp, err := g.client.Repositories.GetContents(context.Background(), g.Config.AuthorName, g.Config.Repository, fileName, nil)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	content, err := file.GetContent()
	if err != nil {
		return err
	}

	source := []byte(content)

	keywords, err := fmtr.FormatRead(source, fileName)
	if err != nil {
		return err
	}

	for _, keyword := range keywords {
		store.Insert(keyword)
	}

	return nil
}

func (g *GithubProvider) DumpData(msg, fileName string, store PublicProviderStore, fmtr Formatter) error {
	g.mu.Lock()
	defer g.mu.Unlock()

	if g.client == nil {
		return errors.New("datasource githubprovider: cannot write to github without a valid access token or client.")
	}
	if g.SourceOnly {
		return errors.New("datasource githubprovider: cannot write to third party source.")
	}

	ctx := context.Background()

	data := store.ListContents()

	content, err := fmtr.FormatWrite(data, fileName)

	branchName := fmt.Sprintf("%s-%s-%d", SERVICE_NAME, msg, time.Now().Unix())

	err = g.getOrCreateBranch(branchName)
	if err != nil {
		return err
	}

	opts := &github.RepositoryContentFileOptions{
		Message:   github.String(msg),
		Content:   content,
		Branch:    github.String(branchName),
		Committer: &github.CommitAuthor{Name: github.String(g.Config.AuthorName), Email: github.String(g.Config.AuthorEmail)},
	}

	_, _, err = g.client.Repositories.CreateFile(ctx, g.Config.AuthorName, g.Config.Repository, fileName, opts)
	if err != nil {
		return err
	}

	return nil
}

func (g *GithubProvider) getOrCreateBranch(branchName string) error {
	ctx := context.Background()

	_, _, err := g.client.Git.GetRef(ctx, g.Config.AuthorName, g.Config.Repository, "refs/heads/"+branchName)
	if err == nil {
		// Branch exists, we can move on.
		return nil
	}

	baseRef, _, err := g.client.Git.GetRef(ctx, g.Config.AuthorName, g.Config.Repository, "refs/heads/"+g.Config.BaseBranch)
	if err != nil {
		return err
	}

	newRef := &github.Reference{Ref: github.String("refs/heads/" + branchName), Object: &github.GitObject{SHA: baseRef.Object.SHA}}
	_, _, err = g.client.Git.CreateRef(ctx, g.Config.AuthorName, g.Config.Repository, newRef)
	if err != nil {
		return err
	}

	return nil
}

// TODO: Future provider
type BitbucketProvider struct{}

// GoogleStorageBucketProvider is a provider for reading and writing data to a Google Storage Bucket.
// Will work for both Private and Public buckets so long that your GOOGLE_APPLICATION_CREDENTIALS
// environment variable or GoogleStorageBucketProvider.credentials  is set to a valid service account json file.
type GoogleStorageBucketProvider struct {
	BucketName string
	// DefaultTimeout will be 5 minutes.
	DefaultTimeout time.Duration

	credentials  *google.Credentials
	client       *storage.Client
	clientClosed bool

	mu sync.Mutex
}

// Pass 0 for timeout if you wish to use a default timeout.
func NewGoogleStorageBucketProvider(name string, timeout time.Duration, creds *google.Credentials) (*GoogleStorageBucketProvider, error) {
	ctx := context.Background()
	client, err := storage.NewClient(ctx)
	if err != nil {
		return nil, err
	}

	bucket := &GoogleStorageBucketProvider{BucketName: name, credentials: creds, client: client}
	if timeout == 0 {
		bucket.DefaultTimeout = 5 * time.Minute
	} else {
		bucket.DefaultTimeout = timeout
	}
	return bucket, nil
}

// Deciding to only close on the client, instead of tracking weather or not a
// read operation or write operation was being performed and closing that reader
// and writer. Might have to change this.
func (g *GoogleStorageBucketProvider) Close() error {
	g.mu.Lock()
	defer g.mu.Unlock()

	if g.clientClosed || g.client == nil {
		return nil
	}

	err := g.client.Close()
	if err != nil {
		return err
	}

	g.clientClosed = true

	return nil
}

func (g *GoogleStorageBucketProvider) ReadData(fileName string, store PublicProviderStore, fmtr Formatter) error {
	g.mu.Lock()
	defer g.mu.Unlock()
	if g.client == nil {
		return errors.New("datasource googlestoragebucketprovider: cannot read from google storage without a valid client.")
	}
	// Creates a local scope for cancellation..
	// TODO: In the future consider passing contexts and return contexts instead.
	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, g.DefaultTimeout)

	defer cancel()
	rdr, err := g.client.Bucket(g.BucketName).Object(fileName).NewReader(ctx)
	if err != nil {
		return err
	}
	defer rdr.Close()

	byts, err := io.ReadAll(rdr)
	if err != nil {
		return err
	}

	keywords, err := fmtr.FormatRead(byts, fileName)
	if err != nil {
		return err
	}

	for _, keyword := range keywords {
		store.Insert(keyword)
	}

	return nil
}

func (g *GoogleStorageBucketProvider) DumpData(fileName string, store PublicProviderStore, fmtr Formatter) error {
	g.mu.Lock()
	defer g.mu.Unlock()
	if g.client == nil {
		return errors.New("datasource googlestoragebucketprovider: cannot read from google storage without a valid client.")
	}

	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, g.DefaultTimeout)
	defer cancel()

	keywords := store.ListContents()

	content, err := fmtr.FormatWrite(keywords, fileName)
	if err != nil {
		return err
	}

	wc := g.client.Bucket(g.BucketName).Object(fileName).NewWriter(ctx)

	wc.ChunkSize = 25 << 20

	if _, err := io.Copy(wc, bytes.NewReader(content)); err != nil {
		return err
	}

	if err := wc.Close(); err != nil {
		return err
	}

	return nil
}

var _ io.Writer = (*LocalFileProvider)(nil)

// Use a local file to read and write data.
type LocalFileProvider struct {
	*os.File

	mu       sync.RWMutex
	Filename string
	closed   bool
}

func NewLocalFileProvider(fileName string) (*LocalFileProvider, error) {
	return &LocalFileProvider{Filename: fileName}, nil
}

func (l *LocalFileProvider) ReadData(fileName string, store PublicProviderStore, fmtr Formatter) error {
	l.mu.RLock()
	defer l.mu.RUnlock()

	var err error
	l.File, err = os.OpenFile(l.Filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}

	defer l.Close()

	chunk := make([]byte, 1<<10)

	for {
		n, err := l.Read(chunk)
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}

		keywords, err := fmtr.FormatRead(chunk[:n], fileName)
		if err != nil {
			return err
		}

		for _, keyword := range keywords {
			store.Insert(keyword)
		}
	}

	return nil
}

func (l *LocalFileProvider) DumpData(fileName string, store PublicProviderStore, fmtr Formatter) error {
	l.mu.Lock()
	defer l.mu.Unlock()

	var err error
	l.File, err = os.OpenFile(l.Filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer l.Close()

	contents := store.ListContents()

	content, err := fmtr.FormatWrite(contents, fileName)
	if err != nil {
		return err
	}
	_, err = l.Write(content)

	return err
}

// My thought here is if the AutocompleteService.Close() is called while a write
// or read operation is currently in progress. We can go ahead and shut it down.
func (l *LocalFileProvider) Close() error {
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.closed || l.File == nil {
		return nil
	}

	l.closed = true

	return l.File.Close()
}
